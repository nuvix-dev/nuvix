import * as fs from 'node:fs'
import * as path from 'node:path'

interface ParamInfo {
  name: string
  type: 'string' | 'number' | 'date' | 'boolean'
  required: boolean
}

/**
 * Extract parameters from a translation template
 */
function extractParams(template: string): ParamInfo[] {
  const params: ParamInfo[] = []
  const seen = new Set<string>()

  // Extract mustache variables: {{variable}}
  const mustacheRegex = /\{\{(?![#/])(\w+)\}\}/g
  let match: RegExpExecArray | null

  while ((match = mustacheRegex.exec(template)) !== null) {
    const name = match[1]!
    if (!seen.has(name)) {
      seen.add(name)
      params.push({ name, type: 'string', required: true })
    }
  }

  // Extract positional sprintf args: %s
  const sprintfMatches = template.match(/%s/g)
  if (sprintfMatches) {
    for (let i = 0; i < sprintfMatches.length; i++) {
      if (!seen.has(String(i))) {
        seen.add(String(i))
        params.push({ name: String(i), type: 'string', required: true })
      }
    }
  }

  return params
}

/**
 * Generate TypeScript type for param object
 */
function generateParamType(params: ParamInfo[]): string {
  if (params.length === 0) return 'void'

  const fields = params.map(p => {
    const optional = p.required ? '' : '?'
    return `${p.name}${optional}: ${p.type}`
  })

  return `{ ${fields.join('; ')} }`
}

/**
 * Parse translation file and generate types
 */
function generateTypes(translationFile: string, outputFile: string): void {
  const content = fs.readFileSync(translationFile, 'utf-8')
  const translations = JSON.parse(content) as Record<string, any>

  const lines: string[] = [
    '// Auto-generated by scripts/generate-i18n-types.ts',
    '// Do not edit manually - regenerate with: npm run i18n:types',
    '',
    '/**',
    ' * All available translation keys',
    ' */',
    'export type TranslationKey =',
  ]

  const keys = Object.keys(translations).sort()
  keys.forEach((key, index) => {
    const isLast = index === keys.length - 1
    lines.push(`  | '${key}'${isLast ? '' : ''}`)
  })

  lines.push(
    '',
    '/**',
    ' * Parameter requirements for each translation key',
    ' */',
  )
  lines.push('export interface TranslationParams {')

  for (const key of keys) {
    const value = translations[key]
    let template: string

    // Handle both simple strings and objects with "_" property
    if (typeof value === 'string') {
      template = value
    } else if (typeof value === 'object' && value._ !== undefined) {
      template = value._
    } else {
      continue
    }

    const params = extractParams(template)
    const paramType = generateParamType(params)

    lines.push(`  '${key}': ${paramType}`)
  }

  lines.push('}')

  lines.push(
    '',
    '/**',
    ' * Helper type to get params for a specific key',
    ' */',
    'export type ParamsFor<K extends TranslationKey> = TranslationParams[K]',
    '',
    '/**',
    ' * Check if a key requires parameters',
    ' */',
    'export type RequiresParams<K extends TranslationKey> = TranslationParams[K] extends void ? false : true',
  )

  fs.writeFileSync(outputFile, lines.join('\n'))
  console.log(`âœ… Generated types: ${outputFile}`)
  console.log(`   Keys: ${keys.length}`)
}

// Run the generator
const localeDir = path.join(process.cwd(), 'assets', 'locale', 'translations')
const outputDir = path.join(process.cwd(), 'libs', 'core', 'src', 'i18n')

// Ensure output directory exists
if (!fs.existsSync(outputDir)) {
  fs.mkdirSync(outputDir, { recursive: true })
}

generateTypes(
  path.join(localeDir, 'en.json'),
  path.join(outputDir, 'translation-keys.generated.ts'),
)
